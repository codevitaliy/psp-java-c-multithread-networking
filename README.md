# Knowledge Acquired ‚Äì Java Multithreading üßµ

This work allowed me to strengthen key knowledge about **concurrent programming in Java**, understanding how to manage multiple threads and coordinate their execution in a safe and efficient way.  

---

## üîë Main Concepts

### 1. Thread creation and management
- Differences between **extending `Thread`** and **implementing `Runnable`**.  
- Life cycle of a thread: creation, start, execution, termination.  
- Use of methods like `start()`, `run()`, `sleep()`, `join()` to control execution.  

### 2. Process synchronization
- Use of the **`synchronized`** keyword to prevent race conditions.  
- Coordination between threads using **`wait()`**, **`notify()`**, and **`notifyAll()`**.  
- Understanding of **monitors** to control shared resources.  

### 3. Communication and shared resources
- How multiple threads interact with **shared data structures**.  
- Common issues: **data inconsistency**, **deadlocks**, and how to avoid them.  
- Applied design patterns: **producer-consumer** and **reader-writer**.  

### 4. Concurrency in distributed applications
- Use of **TCP sockets** for inter-process communication.  
- Sending information through **object serialization**.  
- Managing multiple clients concurrently in a server environment.  

### 5. Object-oriented design and concurrency
- Separation of responsibilities into classes to organize concurrent logic.  
- Application of **modularity and encapsulation** principles in multithreaded systems.  
- Safe handling and resetting of shared state after each execution.  

---

## üìö Skills Developed
- Ability to program **multithreaded applications** in Java.  
- Clear understanding of **parallelism vs concurrency**.  
- Application of **synchronization and coordination** mechanisms.  
- Detection and prevention of classic concurrency problems (deadlocks, race conditions, busy waiting).  
- Development of **concurrent client-server applications** using sockets.  
- Improved logical reasoning for structuring concurrent workflows.  

---

## üöÄ Conclusion
This learning experience enables me to:
- Tackle projects where multiple processes must run simultaneously.  
- Design **robust and scalable systems** with many clients or actors working at once.  
- Apply concurrency foundations to advanced areas such as:  
  - **parallel processing**,  
  - **high-performance servers**,  
  - **distributed simulations**,  
  - **real-time systems**.  

In summary, I consolidated a practical vision of **concurrency in Java**, understanding both its benefits and its challenges.  

---

# Conocimientos Adquiridos ‚Äì Java Multithreading üßµ

Este trabajo me permiti√≥ afianzar conocimientos clave sobre la **programaci√≥n concurrente en Java**, comprendiendo c√≥mo gestionar m√∫ltiples hilos y coordinar su ejecuci√≥n de forma segura y eficiente.  

---

## üîë Conceptos principales

### 1. Creaci√≥n y gesti√≥n de hilos
- Diferencias entre **extender la clase `Thread`** e **implementar `Runnable`**.  
- Ciclo de vida de un hilo: creaci√≥n, inicio, ejecuci√≥n, finalizaci√≥n.  
- Uso de m√©todos como `start()`, `run()`, `sleep()`, `join()` para controlar la ejecuci√≥n.  

### 2. Sincronizaci√≥n de procesos
- Empleo de la palabra clave **`synchronized`** para evitar condiciones de carrera.  
- Coordinaci√≥n entre hilos usando **`wait()`**, **`notify()`** y **`notifyAll()`**.  
- Comprensi√≥n del uso de **monitores** en la gesti√≥n de recursos compartidos.  

### 3. Comunicaci√≥n y recursos compartidos
- C√≥mo varios hilos interact√∫an con **estructuras de datos compartidas**.  
- Problemas comunes: **inconsistencia de datos**, **interbloqueos (deadlocks)** y c√≥mo evitarlos.  
- Patrones de dise√±o aplicados: **productor-consumidor** y **lector-escritor**.  

### 4. Concurrencia en aplicaciones distribuidas
- Uso de **sockets TCP** para la comunicaci√≥n entre procesos.  
- Env√≠o de informaci√≥n mediante **serializaci√≥n de objetos**.  
- Gesti√≥n de m√∫ltiples clientes de manera concurrente en un servidor.  

### 5. Dise√±o orientado a objetos y concurrencia
- Separaci√≥n de responsabilidades en distintas clases para organizar la l√≥gica concurrente.  
- Aplicaci√≥n de principios de **modularidad y encapsulaci√≥n** en sistemas multihilo.  
- Manejo seguro y reinicio del estado compartido tras cada ejecuci√≥n.  

---

## üìö Competencias desarrolladas
- Programar aplicaciones **multihilo** en Java de forma estructurada.  
- Comprender la diferencia entre **paralelismo** y **concurrencia**.  
- Aplicar mecanismos de **sincronizaci√≥n y coordinaci√≥n** entre procesos.  
- Detectar y prevenir problemas cl√°sicos de concurrencia (bloqueos, condiciones de carrera, espera activa).  
- Desarrollar aplicaciones **cliente-servidor concurrentes** con sockets.  
- Mejorar la capacidad de **razonamiento l√≥gico** para estructurar flujos de trabajo concurrentes.  

---

## üöÄ Conclusi√≥n
Este aprendizaje me permite:
- Afrontar proyectos donde varios procesos deben ejecutarse de forma simult√°nea.  
- Dise√±ar **sistemas robustos y escalables** con m√∫ltiples clientes o actores trabajando a la vez.  
- Aplicar las bases de la concurrencia en √°mbitos m√°s avanzados como:  
  - **procesamiento paralelo**,  
  - **servidores de alto rendimiento**,  
  - **simulaciones distribuidas**,  
  - **sistemas de tiempo real**.  

En resumen, consolid√© una visi√≥n pr√°ctica de la **concurrencia en Java**, entendiendo tanto sus beneficios como sus desaf√≠os.  
